\documentclass[12pt]{article}
\usepackage[left=2cm, right=2cm, top=3cm, bottom=3cm]{geometry}
\usepackage{fontspec}
\usepackage{url}
\usepackage{parskip} 

\setmainfont{Barlow} % Cambiar la fuente principal a Arial

\usepackage{listings}
\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\title{Revisión de una Metodología para la Extracción, Limpieza y Organización de Datos SQL con Programación Declarativa en Python para el Desarrollo de Análisis de Datos Descriptivos.}

\begin{document}
\maketitle

\section{Procedimientos ETL}

Recordemos que los procedimientos ETL constan de Extract, Transform y Load, los cuales nos dan la pauta a seguir para seguir el ciclo de la Ingeniería de Datos. De esta forma seguimos una metodología establecida y evitamos estar trabajando sin una dirección específica.

\vspace{12pt}

En este ejemplo, se utilizará la base de datos de Sakila, la cual es una base de datos ejemplo proporcionada por MySQL que es utilizada comúnmente para propósitos educativos, demostraciones y pruebas. Sakila simula una base de datos de una tienda de alquiler de películas, similar a la cadena de alquiler de vídeos Blockbuster que solía existir.

\vspace{12pt}

Sakila contiene tablas que representan películas, actores, clientes, tiendas, alquileres, etc.

\vspace{12pt}

Para hacer uso de ella, hemos descargado el archivo script SQL a través de la página oficial de MySQL: \url{https://dev.mysql.com/doc/index-other.html}.

\vspace{12pt}

Ahora para instalar la base de datos podremos utilizar los siguientes comandos de MySQL.

\vspace{12pt}
\begin{lstlisting}[language=Bash]
    
    $ mysql -u root -p sakila < sakila-schema.sql
    $ mysql -u root -p sakila < sakila-data.sql
    
\end{lstlisting}
\vspace{12pt}

Después de haber ejecutado estos comandos, deberíamos ser capaces de ver la base de datos instalada en nuestro sistema, para comprobarlo podemos ejecutar:

\vspace{12pt}
\begin{lstlisting}[language=Bash]
    
  mysql> USE sakila;
  Database changed
  mysql> SHOW TABLES;
  +----------------------------+
  | Tables_in_sakila                |
  +----------------------------+
  | actor                           |
  | actor_info                      |
  | address                         |
  | category                        |
  | city                            |
  | country                         |
  | customer                        |
  | customer_list                   |
  | film                            |
  | film_actor                      |
  | film_category                   |
  | film_list                       |
  | film_text                       |
  | inventory                       |
  | language                        |
  | nicer_but_slower_film_list      |
  | payment                         |
  | rental                          |
  | sales_by_film_category          |
  | sales_by_store                  |
  | staff                           |
  | staff_list                      |
  | store                           |
  +----------------------------+

    
\end{lstlisting}
\vspace{12pt}

Ahora, con ello podremos comenzar a trabajar nuestro procedimiento ETL.

Primeramente, es necesario determinar que incógnita queremos responder sobre los datos disponibles. Esto variará dependiendo de la base de datos y los tipos de datos que ésta almacene. Para este caso, intentaremos responder las preguntas:

\begin{itemize}
  \item \textbf{Patrones de alquier:} ¿Cuáles son las películas más alquiladas?
\end{itemize}

Una vez planteadas las incógnitas, podemos determinas que tablas serán relevantes para nuestro análisis, las cuales son:

\begin{itemize}
  \item \textbf{Patrones de alquier:}
  \begin{enumerate}
    \item rental
    \item inventory
    \item film
  \end{enumerate}
\end{itemize}

\subsection{Extract.}

Para nuestro ejemplo, utilizaremos Python con SQL Alchemy.

\vspace{12pt}
\begin{lstlisting}[language=Python]
    
  from sqlalchemy import create_engine, MetaData, Table, select, func

  # Configurar la conexión a la base de datos
  engine = create_engine('mysql://starboy:starboyc00l@localhost/sakila')
  metadata = MetaData()
  
  # Asociar el motor a la Metadata después de su creación
  metadata.bind = engine
  
  # Reflejar las tablas
  metadata.reflect(bind=engine)
  
  # Obtener las tablas reflejadas
  rental_table = metadata.tables['rental']
  inventory_table = metadata.tables['inventory']
  film_table = metadata.tables['film']
    
\end{lstlisting}
\vspace{12pt}

En este código hemos creado la conexión respectiva a nuestra base de datos de manera local, donde generamos un "motor" de base de datos que nos permitirá enlazarnos al motor de base de datos de MySQL, podemos pensar en él cómo una "reflejo" de la base de datos original.


\subsection{Transform.}

Ahora bien, después de haber extraído los datos, es necesario organizarlos de manera que sea más sencillo utilizarlos para el análisis de datos.

\vspace{12pt}
\begin{lstlisting}[language=Python]
    
  # Construir la consulta para obtener las películas más alquiladas
  # Obtener las 10 películas más alquiladas
  query = (
      select(film_table.c.title, film_table.c.film_id, func.count(rental_table.c.inventory_id).label('rental_count'))
      .select_from(
          rental_table.join(inventory_table, rental_table.c.inventory_id == inventory_table.c.inventory_id)
          .join(film_table, inventory_table.c.film_id == film_table.c.film_id)
      )
      .group_by(film_table.c.film_id)
      .order_by(func.count(rental_table.c.inventory_id).desc())
      .limit(10)
  )
    
\end{lstlisting}
\vspace{12pt}

De esta forma, en query se almacenarán los datos extraídos de la consulta en la base de datos, de manera que con SQL Alchemy podemos escribir consultas de SQL a través del lenguaje de programación Python, agregando una capa de programación declarativa.
\vspace{12pt}

Para ver los resultados de la consulta anterior podemos realizar lo siguiente:

\vspace{12pt}
\begin{lstlisting}[language=Python]
  # Ejecutar la consulta y obtener los resultados
  with engine.connect() as connection:
    result = connection.execute(query)
    for row in result:
        print(row)
\end{lstlisting}
\vspace{12pt}

Como respuesta tendríamos que ver algo como lo siguiente:

\vspace{12pt}
\begin{lstlisting}[language=Bash]
  $ python3 main.py 

  metadata.reflect(bind=engine)
  ('BUCKET BROTHERHOOD', 103, 34)
  ('ROCKETEER MOTHER', 738, 33)
  ('RIDGEMONT SUBMARINE', 730, 32)
  ('GRIT CLOCKWORK', 382, 32)
  ('SCALAWAG DUCK', 767, 32)
  ('JUGGLER HARDLY', 489, 32)
  ('FORWARD TEMPLE', 331, 32)
  ('HOBBIT ALIEN', 418, 31)
  ('ROBBERS JOON', 735, 31)
  ('ZORRO ARK', 1000, 31)
\end{lstlisting}
\vspace{12pt}

\subsection{Load.}

Una vez que se haya realizado la Organización de los datos, es una buena idea es crear un acceso a esta información de manera que no sea necesario acceder a la información y organizarla nuevamente, para esto son muy útiles las vistas (views) de SQL.

\vspace{12pt}
\begin{lstlisting}[language=Python]
    
  # Crear una vista en la base de datos a partir de la consulta
  view_name = "top_rented_films"
  create_view_query = text(f"CREATE OR REPLACE VIEW {view_name} AS {str(query.compile(engine, compile_kwargs={'literal_binds': True}))}")
  
  with engine.begin() as conn:
      conn.execute(create_view_query)
      print(f"Vista '{view_name}' creada exitosamente.")
  
  # Consultar la información de la vista
  view = Table(view_name, metadata, autoload_with=engine)
  
  # Consultar la información de la vista
  with engine.connect() as connection:
      result = connection.execute(select(view))
      for row in result:
          print(row)
    
\end{lstlisting}
\vspace{12pt}

\section{Python y sus librerías}

Python cuenta con muchas librerías para manejo de información y para diferentes actividades, por ahora nos centraremos en una específicamente, la cual es SQLAlchemy.

\subsection{SQLAlchemy}

SQLAlchemy es un conjunto de herramientas de software y una biblioteca de Python que facilita la comunicación entre la aplicación de Python y las bases de datos relacionales. 

En otras palabras, es un \textbf{Mapeador de Objetos Relaciones} o ORM, el cual traduce las clases de Python a tablas de bases de datos relacionales y viceversa. Proporcionando una capa de abstracción sobre la base de datos que permite escribir consultas utilizando lenguaje Python en lugar de SQL.

Para instalar esta librería, requiere de ciertas dependencias, gracias a la versatilidad de Linux (Fedora), podemos hacerlo de la siguiente manera:

\begin{lstlisting}[language=Bash]
  $ sudo yum install python3-devel mysql-devel gcc
  $ pip install mysqlclient
\end{lstlisting}

Ahora, para manejar correctamente un proyecto de python ejecutaremos los siguientes comandos en una carpeta donde almacenaremos nuestro proyecto.

\begin{lstlisting}[language=Bash]
  $ mkdir proyecto
  $ cd proyecto
  /proyecto$ python3 -m venv venv
  /proyecto$ touch main.py
\end{lstlisting}
\vspace{12pt}

Con esto, ya tendremos la estructura básica de nuestro proyecto, pero será necesario utilizar en entorno virtual de Python recién creado para instalar la librería de SQLAlchemy, lo podemos realizar de la siguiente forma.

\begin{lstlisting}[language=Bash]
  /proyecto$ source venv/bin/activate
  (venv) /proyecto$ pip install sqlalchemy
\end{lstlisting}
\vspace{12pt}

De esta forma, ya tenemos la librería instalada y haremos uso de ella de la siguiente forma.

\begin{lstlisting}[language=Python]
  from sqlalchemy import create_engin

  # Configurar la conexión a la base de datos

  engine = create_engine('mysql://user:password@localhost/sakila')
\end{lstlisting}
\vspace{12pt}













\end{document}
